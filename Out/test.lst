C51 COMPILER V9.60.7.0   TEST                                                              06/19/2024 11:58:06 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TEST
OBJECT MODULE PLACED IN .\Out\test.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE test.c LARGE OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Out\tes
                    -t.lst) TABS(2) OBJECT(.\Out\test.obj)

line level    source

   1          #include <REG52.H> /* special function register declarations   */
   2          /* for the intended 8051 derivative         */
   3          #include <stdio.h>
   4          #include "timestamp.h"
   5          
   6          #ifdef MONITOR51                /* Debugging with Monitor-51 needs   */
              char code reserve[3] _at_ 0x23; /* space for serial interrupt if     */
              #endif                          /* Stop Exection with Serial Intr.   */
   9          
  10          void L_pok_init(void)
  11          {
  12   1      #ifndef MONITOR51
  13   1          SCON = 0x50;  /* SCON: mode 1, 8-bit UART, enable rcvr      */
  14   1          TMOD |= 0x20; /* TMOD: timer 1, mode 2, 8-bit reload        */
  15   1          TH1 = 221;    /* TH1:  reload value for 1200 baud @ 16MHz   */
  16   1          TR1 = 1;      /* TR1:  timer 1 run                          */
  17   1          TI = 1;       /* TI:   set TI to send first char of UART    */
  18   1      #endif
  19   1      }
  20          
  21          TS_time_ time_struct;
  22          
  23          uint32_t leapyear_check(uint32_t y)
  24          {
  25   1          return (0 == y % 4 && y % 100 != 0) || y % 400 == 0;
  26   1      }
  27          
  28          const uint32_t month_buf[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  29          
  30          uint32_t TS2RTC(uint32_t unixtimestamp, TS_time_ *RTC_out)
  31          {
  32   1          uint32_t min_add, hour_add, day_add, mon_add = 0, year_add = 0;
  33   1          uint32_t day_temp, mon_temp, year_temp;
  34   1          uint32_t i, a, temp;
  35   1      
  36   1          RTC_out->h_year = 19;
  37   1          RTC_out->l_year = 70;
  38   1          RTC_out->mon = 1;
  39   1          RTC_out->day = 1;
  40   1          RTC_out->hour = 0;
  41   1          RTC_out->min = 0;
  42   1          RTC_out->sec = 0;
  43   1      
  44   1          min_add = unixtimestamp / 60;
  45   1          RTC_out->sec = (uint8_t)(unixtimestamp % 60);
  46   1      
  47   1          hour_add = min_add / 60;
  48   1          RTC_out->min = (uint8_t)(min_add % 60);
  49   1      
  50   1          day_add = hour_add / 24;
  51   1          RTC_out->hour = (uint8_t)(hour_add % 24);
  52   1      
  53   1          day_temp = RTC_out->hour;
  54   1      
C51 COMPILER V9.60.7.0   TEST                                                              06/19/2024 11:58:06 PAGE 2   

  55   1          for (i = RTC_out->mon - 1;; i++)
  56   1          {
  57   2              a = i % 12;
  58   2              year_temp = RTC_out->h_year * 100 + RTC_out->l_year + (i / 12);
  59   2              temp = (a == 1 && leapyear_check(year_temp)) ? (month_buf[a] + 1) : month_buf[a];
  60   2      
  61   2              if (mon_add)
  62   2              {
  63   3                  day_temp = 1;
  64   3              }
  65   2      
  66   2              if (day_add + day_temp > temp)
  67   2              {
  68   3                  mon_add++;
  69   3                  day_add -= (temp - day_temp + 1);
  70   3              }
  71   2              else
  72   2              {
  73   3                  RTC_out->day += day_add;
  74   3                  break;
  75   3              }
  76   2          }
  77   1      
  78   1          mon_temp = RTC_out->mon + mon_add;
  79   1          year_add = (mon_temp % 12 == 0) ? mon_temp / 12 - 1 : mon_temp / 12;
  80   1          RTC_out->mon = (uint8_t)((mon_temp % 12 == 0) ? 12 : mon_temp % 12);
  81   1      
  82   1          if (year_add > 30)
  83   1          {
  84   2              year_add -= 30;
  85   2              RTC_out->h_year = (uint8_t)(20 + year_add / 100);
  86   2              year_add = year_add % 100;
  87   2              RTC_out->l_year = 0;
  88   2          }
  89   1          else
  90   1              RTC_out->h_year = 19;
  91   1      
  92   1          RTC_out->l_year += (uint8_t)year_add;
  93   1      
  94   1          if (RTC_out->h_year != 19 && RTC_out->l_year != 70 && RTC_out->mon != 1 && RTC_out->day != 1 && RTC_ou
             -t->hour != 0 && RTC_out->min != 0 && RTC_out->sec != 0)
  95   1              return 1;
  96   1          return -1;
  97   1      }
  98          
  99          uint32_t timetostamp(TS_time_ t_in)
 100          {
 101   1          uint32_t stamp = 0;
 102   1          uint32_t h_year = (uint32_t)t_in.h_year;
 103   1          uint32_t h_yearMULTI100 = h_year * 100;
 104   1          uint32_t l_year = (uint32_t)t_in.l_year;
 105   1          uint32_t year = h_yearMULTI100 + l_year;
 106   1          uint32_t y;
 107   1          uint32_t daySUB1 = (uint32_t)(t_in.day - 1);
 108   1          uint32_t day2stamp = daySUB1 * 86400;
 109   1          uint32_t hour = (uint32_t)t_in.hour;
 110   1          uint32_t hour2stamp = hour * 3600;
 111   1          uint32_t min2stamp = (uint32_t)t_in.min * 60;
 112   1          uint32_t sec2stamp = (uint32_t)t_in.sec;
 113   1          uint32_t m;
 114   1      
 115   1          for (y = 1970; y < year; y++)
C51 COMPILER V9.60.7.0   TEST                                                              06/19/2024 11:58:06 PAGE 3   

 116   1              stamp += leapyear_check(y) ? 366 * 86400 : 365 * 86400;
 117   1      
 118   1          for (m = 0; m < (uint32_t)(t_in.mon - 1); m++)
 119   1              if (m == 1 && leapyear_check(year))
 120   1                  stamp += 29 * 86400;
 121   1              else
 122   1                  stamp += month_buf[m] * 86400;
 123   1      
 124   1          stamp += day2stamp + hour2stamp + min2stamp + sec2stamp;
 125   1      
 126   1          return stamp;
 127   1      }
 128          
 129          void main(void)
 130          {
 131   1          uint32_t unixtimestamp;
 132   1          TS_time_ t_in;
 133   1          TS_time_ t_out;
 134   1          uint32_t stamp;
 135   1      
 136   1          uint32_t t_in_h_year;
 137   1          uint32_t t_in_l_year;
 138   1          uint32_t t_in_mon;
 139   1          uint32_t t_in_day;
 140   1          uint32_t t_in_hour;
 141   1          uint32_t t_in_min;
 142   1          uint32_t t_in_sec;
 143   1      
 144   1          unixtimestamp = 1704071461;
 145   1          t_out.h_year = 20;
 146   1          t_out.l_year = 24;
 147   1          t_out.mon = 1;
 148   1          t_out.day = 1;
 149   1          t_out.hour = 1;
 150   1          t_out.min = 11;
 151   1          t_out.sec = 1;
 152   1      
 153   1          L_pok_init();
 154   1      
 155   1          while (1)
 156   1          {
 157   2              TS2RTC(unixtimestamp, &t_in);
 158   2              t_in_h_year = (uint32_t)t_in.h_year;
 159   2              t_in_l_year = (uint32_t)t_in.l_year;
 160   2              t_in_mon = (uint32_t)t_in.mon;
 161   2              t_in_day = (uint32_t)t_in.day;
 162   2              t_in_hour = (uint32_t)t_in.hour;
 163   2              t_in_min = (uint32_t)t_in.min;
 164   2              t_in_sec = (uint32_t)t_in.sec;
 165   2      
 166   2              printf("%02lu%02lu-%02lu-%02lu %02lu:%02lu:%02lu\n", t_in.h_year, t_in.l_year, t_in.mon, t_in.day,
             - t_in.hour, t_in.min, t_in.sec);
 167   2      
 168   2              stamp = timetostamp(t_out);
 169   2              printf("Unix timestamp: %lu\n", stamp);
 170   2          }
 171   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3612    ----
   CONSTANT SIZE    =     63    ----
C51 COMPILER V9.60.7.0   TEST                                                              06/19/2024 11:58:06 PAGE 4   

   XDATA SIZE       =    303    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
